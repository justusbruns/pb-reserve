{"version":3,"file":"D3t6v8w7.js","sources":["../../../../../../node_modules/svelte/src/runtime/internal/environment.js","../../../../../../node_modules/svelte/src/runtime/internal/loop.js","../../../../../../node_modules/svelte/src/runtime/internal/dom.js","../../../../../../node_modules/svelte/src/runtime/internal/style_manager.js","../../../../../../node_modules/svelte/src/runtime/internal/transitions.js","../../../../../../node_modules/svelte/src/runtime/internal/Component.js","../../../../../../node_modules/svelte/src/shared/version.js","../../../../../../node_modules/svelte/src/runtime/internal/disclose-version/index.js"],"sourcesContent":["import { noop } from './utils.js';\n\nexport const is_client = typeof window !== 'undefined';\n\n/** @type {() => number} */\nexport let now = is_client ? () => window.performance.now() : () => Date.now();\n\nexport let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;\n\n// used internally for testing\n/** @returns {void} */\nexport function set_now(fn) {\n\tnow = fn;\n}\n\n/** @returns {void} */\nexport function set_raf(fn) {\n\traf = fn;\n}\n","import { raf } from './environment.js';\n\nconst tasks = new Set();\n\n/**\n * @param {number} now\n * @returns {void}\n */\nfunction run_tasks(now) {\n\ttasks.forEach((task) => {\n\t\tif (!task.c(now)) {\n\t\t\ttasks.delete(task);\n\t\t\ttask.f();\n\t\t}\n\t});\n\tif (tasks.size !== 0) raf(run_tasks);\n}\n\n/**\n * For testing purposes only!\n * @returns {void}\n */\nexport function clear_loops() {\n\ttasks.clear();\n}\n\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n * @param {import('./private.js').TaskCallback} callback\n * @returns {import('./private.js').Task}\n */\nexport function loop(callback) {\n\t/** @type {import('./private.js').TaskEntry} */\n\tlet task;\n\tif (tasks.size === 0) raf(run_tasks);\n\treturn {\n\t\tpromise: new Promise((fulfill) => {\n\t\t\ttasks.add((task = { c: callback, f: fulfill }));\n\t\t}),\n\t\tabort() {\n\t\t\ttasks.delete(task);\n\t\t}\n\t};\n}\n","import { contenteditable_truthy_values, has_prop } from './utils.js';\n\nimport { ResizeObserverSingleton } from './ResizeObserverSingleton.js';\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\n\n/**\n * @returns {void}\n */\nexport function start_hydrating() {\n\tis_hydrating = true;\n}\n\n/**\n * @returns {void}\n */\nexport function end_hydrating() {\n\tis_hydrating = false;\n}\n\n/**\n * @param {number} low\n * @param {number} high\n * @param {(index: number) => number} key\n * @param {number} value\n * @returns {number}\n */\nfunction upper_bound(low, high, key, value) {\n\t// Return first index of value larger than input value in the range [low, high)\n\twhile (low < high) {\n\t\tconst mid = low + ((high - low) >> 1);\n\t\tif (key(mid) <= value) {\n\t\t\tlow = mid + 1;\n\t\t} else {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\treturn low;\n}\n\n/**\n * @param {NodeEx} target\n * @returns {void}\n */\nfunction init_hydrate(target) {\n\tif (target.hydrate_init) return;\n\ttarget.hydrate_init = true;\n\t// We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n\n\tlet children = /** @type {ArrayLike<NodeEx2>} */ (target.childNodes);\n\t// If target is <head>, there may be children without claim_order\n\tif (target.nodeName === 'HEAD') {\n\t\tconst my_children = [];\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tconst node = children[i];\n\t\t\tif (node.claim_order !== undefined) {\n\t\t\t\tmy_children.push(node);\n\t\t\t}\n\t\t}\n\t\tchildren = my_children;\n\t}\n\t/*\n\t * Reorder claimed children optimally.\n\t * We can reorder claimed children optimally by finding the longest subsequence of\n\t * nodes that are already claimed in order and only moving the rest. The longest\n\t * subsequence of nodes that are claimed in order can be found by\n\t * computing the longest increasing subsequence of .claim_order values.\n\t *\n\t * This algorithm is optimal in generating the least amount of reorder operations\n\t * possible.\n\t *\n\t * Proof:\n\t * We know that, given a set of reordering operations, the nodes that do not move\n\t * always form an increasing subsequence, since they do not move among each other\n\t * meaning that they must be already ordered among each other. Thus, the maximal\n\t * set of nodes that do not move form a longest increasing subsequence.\n\t */\n\t// Compute longest increasing subsequence\n\t// m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n\tconst m = new Int32Array(children.length + 1);\n\t// Predecessor indices + 1\n\tconst p = new Int32Array(children.length);\n\tm[0] = -1;\n\tlet longest = 0;\n\tfor (let i = 0; i < children.length; i++) {\n\t\tconst current = children[i].claim_order;\n\t\t// Find the largest subsequence length such that it ends in a value less than our current value\n\t\t// upper_bound returns first greater value, so we subtract one\n\t\t// with fast path for when we are on the current longest subsequence\n\t\tconst seq_len =\n\t\t\t(longest > 0 && children[m[longest]].claim_order <= current\n\t\t\t\t? longest + 1\n\t\t\t\t: upper_bound(1, longest, (idx) => children[m[idx]].claim_order, current)) - 1;\n\t\tp[i] = m[seq_len] + 1;\n\t\tconst new_len = seq_len + 1;\n\t\t// We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n\t\tm[new_len] = i;\n\t\tlongest = Math.max(new_len, longest);\n\t}\n\t// The longest increasing subsequence of nodes (initially reversed)\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst lis = [];\n\t// The rest of the nodes, nodes that will be moved\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst to_move = [];\n\tlet last = children.length - 1;\n\tfor (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n\t\tlis.push(children[cur - 1]);\n\t\tfor (; last >= cur; last--) {\n\t\t\tto_move.push(children[last]);\n\t\t}\n\t\tlast--;\n\t}\n\tfor (; last >= 0; last--) {\n\t\tto_move.push(children[last]);\n\t}\n\tlis.reverse();\n\t// We sort the nodes being moved to guarantee that their insertion order matches the claim order\n\tto_move.sort((a, b) => a.claim_order - b.claim_order);\n\t// Finally, we move the nodes\n\tfor (let i = 0, j = 0; i < to_move.length; i++) {\n\t\twhile (j < lis.length && to_move[i].claim_order >= lis[j].claim_order) {\n\t\t\tj++;\n\t\t}\n\t\tconst anchor = j < lis.length ? lis[j] : null;\n\t\ttarget.insertBefore(to_move[i], anchor);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @returns {void}\n */\nexport function append(target, node) {\n\ttarget.appendChild(node);\n}\n\n/**\n * @param {Node} target\n * @param {string} style_sheet_id\n * @param {string} styles\n * @returns {void}\n */\nexport function append_styles(target, style_sheet_id, styles) {\n\tconst append_styles_to = get_root_for_style(target);\n\tif (!append_styles_to.getElementById(style_sheet_id)) {\n\t\tconst style = element('style');\n\t\tstyle.id = style_sheet_id;\n\t\tstyle.textContent = styles;\n\t\tappend_stylesheet(append_styles_to, style);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {ShadowRoot | Document}\n */\nexport function get_root_for_style(node) {\n\tif (!node) return document;\n\tconst root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n\tif (root && /** @type {ShadowRoot} */ (root).host) {\n\t\treturn /** @type {ShadowRoot} */ (root);\n\t}\n\treturn node.ownerDocument;\n}\n\n/**\n * @param {Node} node\n * @returns {CSSStyleSheet}\n */\nexport function append_empty_stylesheet(node) {\n\tconst style_element = element('style');\n\t// For transitions to work without 'style-src: unsafe-inline' Content Security Policy,\n\t// these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.\n\t// Using the hash for the empty string (for an empty tag) works in all browsers except Safari.\n\t// So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.\n\t// The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.\n\tstyle_element.textContent = '/* empty */';\n\tappend_stylesheet(get_root_for_style(node), style_element);\n\treturn style_element.sheet;\n}\n\n/**\n * @param {ShadowRoot | Document} node\n * @param {HTMLStyleElement} style\n * @returns {CSSStyleSheet}\n */\nfunction append_stylesheet(node, style) {\n\tappend(/** @type {Document} */ (node).head || node, style);\n\treturn style.sheet;\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @returns {void}\n */\nexport function append_hydration(target, node) {\n\tif (is_hydrating) {\n\t\tinit_hydrate(target);\n\t\tif (\n\t\t\ttarget.actual_end_child === undefined ||\n\t\t\t(target.actual_end_child !== null && target.actual_end_child.parentNode !== target)\n\t\t) {\n\t\t\ttarget.actual_end_child = target.firstChild;\n\t\t}\n\t\t// Skip nodes of undefined ordering\n\t\twhile (target.actual_end_child !== null && target.actual_end_child.claim_order === undefined) {\n\t\t\ttarget.actual_end_child = target.actual_end_child.nextSibling;\n\t\t}\n\t\tif (node !== target.actual_end_child) {\n\t\t\t// We only insert if the ordering of this node should be modified or the parent node is not target\n\t\t\tif (node.claim_order !== undefined || node.parentNode !== target) {\n\t\t\t\ttarget.insertBefore(node, target.actual_end_child);\n\t\t\t}\n\t\t} else {\n\t\t\ttarget.actual_end_child = node.nextSibling;\n\t\t}\n\t} else if (node.parentNode !== target || node.nextSibling !== null) {\n\t\ttarget.appendChild(node);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @param {Node} [anchor]\n * @returns {void}\n */\nexport function insert(target, node, anchor) {\n\ttarget.insertBefore(node, anchor || null);\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @param {NodeEx} [anchor]\n * @returns {void}\n */\nexport function insert_hydration(target, node, anchor) {\n\tif (is_hydrating && !anchor) {\n\t\tappend_hydration(target, node);\n\t} else if (node.parentNode !== target || node.nextSibling != anchor) {\n\t\ttarget.insertBefore(node, anchor || null);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {void}\n */\nexport function detach(node) {\n\tif (node.parentNode) {\n\t\tnode.parentNode.removeChild(node);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function destroy_each(iterations, detaching) {\n\tfor (let i = 0; i < iterations.length; i += 1) {\n\t\tif (iterations[i]) iterations[i].d(detaching);\n\t}\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element(name) {\n\treturn document.createElement(name);\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @param {string} is\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element_is(name, is) {\n\treturn document.createElement(name, { is });\n}\n\n/**\n * @template T\n * @template {keyof T} K\n * @param {T} obj\n * @param {K[]} exclude\n * @returns {Pick<T, Exclude<keyof T, K>>}\n */\nexport function object_without_properties(obj, exclude) {\n\tconst target = /** @type {Pick<T, Exclude<keyof T, K>>} */ ({});\n\tfor (const k in obj) {\n\t\tif (\n\t\t\thas_prop(obj, k) &&\n\t\t\t// @ts-ignore\n\t\t\texclude.indexOf(k) === -1\n\t\t) {\n\t\t\t// @ts-ignore\n\t\t\ttarget[k] = obj[k];\n\t\t}\n\t}\n\treturn target;\n}\n\n/**\n * @template {keyof SVGElementTagNameMap} K\n * @param {K} name\n * @returns {SVGElement}\n */\nexport function svg_element(name) {\n\treturn document.createElementNS('http://www.w3.org/2000/svg', name);\n}\n\n/**\n * @param {string} data\n * @returns {Text}\n */\nexport function text(data) {\n\treturn document.createTextNode(data);\n}\n\n/**\n * @returns {Text} */\nexport function space() {\n\treturn text(' ');\n}\n\n/**\n * @returns {Text} */\nexport function empty() {\n\treturn text('');\n}\n\n/**\n * @param {string} content\n * @returns {Comment}\n */\nexport function comment(content) {\n\treturn document.createComment(content);\n}\n\n/**\n * @param {EventTarget} node\n * @param {string} event\n * @param {EventListenerOrEventListenerObject} handler\n * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]\n * @returns {() => void}\n */\nexport function listen(node, event, handler, options) {\n\tnode.addEventListener(event, handler, options);\n\treturn () => node.removeEventListener(event, handler, options);\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function prevent_default(fn) {\n\treturn function (event) {\n\t\tevent.preventDefault();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopPropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_immediate_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopImmediatePropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function self(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.target === this) fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function trusted(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.isTrusted) fn.call(this, event);\n\t};\n}\n\n/**\n * @param {Element} node\n * @param {string} attribute\n * @param {string} [value]\n * @returns {void}\n */\nexport function attr(node, attribute, value) {\n\tif (value == null) node.removeAttribute(attribute);\n\telse if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n}\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nconst always_set_through_set_attribute = ['width', 'height'];\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_attributes(node, attributes) {\n\t// @ts-ignore\n\tconst descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n\tfor (const key in attributes) {\n\t\tif (attributes[key] == null) {\n\t\t\tnode.removeAttribute(key);\n\t\t} else if (key === 'style') {\n\t\t\tnode.style.cssText = attributes[key];\n\t\t} else if (key === '__value') {\n\t\t\t/** @type {any} */ (node).value = node[key] = attributes[key];\n\t\t} else if (\n\t\t\tdescriptors[key] &&\n\t\t\tdescriptors[key].set &&\n\t\t\talways_set_through_set_attribute.indexOf(key) === -1\n\t\t) {\n\t\t\tnode[key] = attributes[key];\n\t\t} else {\n\t\t\tattr(node, key, attributes[key]);\n\t\t}\n\t}\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_svg_attributes(node, attributes) {\n\tfor (const key in attributes) {\n\t\tattr(node, key, attributes[key]);\n\t}\n}\n\n/**\n * @param {Record<string, unknown>} data_map\n * @returns {void}\n */\nexport function set_custom_element_data_map(node, data_map) {\n\tObject.keys(data_map).forEach((key) => {\n\t\tset_custom_element_data(node, key, data_map[key]);\n\t});\n}\n\n/**\n * @returns {void} */\nexport function set_custom_element_data(node, prop, value) {\n\tconst lower = prop.toLowerCase(); // for backwards compatibility with existing behavior we do lowercase first\n\tif (lower in node) {\n\t\tnode[lower] = typeof node[lower] === 'boolean' && value === '' ? true : value;\n\t} else if (prop in node) {\n\t\tnode[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n\t} else {\n\t\tattr(node, prop, value);\n\t}\n}\n\n/**\n * @param {string} tag\n */\nexport function set_dynamic_element_data(tag) {\n\treturn /-/.test(tag) ? set_custom_element_data_map : set_attributes;\n}\n\n/**\n * @returns {void}\n */\nexport function xlink_attr(node, attribute, value) {\n\tnode.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {HTMLElement} node\n * @returns {string}\n */\nexport function get_svelte_dataset(node) {\n\treturn node.dataset.svelteH;\n}\n\n/**\n * @returns {unknown[]} */\nexport function get_binding_group_value(group, __value, checked) {\n\tconst value = new Set();\n\tfor (let i = 0; i < group.length; i += 1) {\n\t\tif (group[i].checked) value.add(group[i].__value);\n\t}\n\tif (!checked) {\n\t\tvalue.delete(__value);\n\t}\n\treturn Array.from(value);\n}\n\n/**\n * @param {HTMLInputElement[]} group\n * @returns {{ p(...inputs: HTMLInputElement[]): void; r(): void; }}\n */\nexport function init_binding_group(group) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\treturn {\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\t_inputs.forEach((input) => group.push(input));\n\t\t},\n\t\t/* remove */ r() {\n\t\t\t_inputs.forEach((input) => group.splice(group.indexOf(input), 1));\n\t\t}\n\t};\n}\n\n/**\n * @param {number[]} indexes\n * @returns {{ u(new_indexes: number[]): void; p(...inputs: HTMLInputElement[]): void; r: () => void; }}\n */\nexport function init_binding_group_dynamic(group, indexes) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _group = get_binding_group(group);\n\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\n\tfunction get_binding_group(group) {\n\t\tfor (let i = 0; i < indexes.length; i++) {\n\t\t\tgroup = group[indexes[i]] = group[indexes[i]] || [];\n\t\t}\n\t\treturn group;\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction push() {\n\t\t_inputs.forEach((input) => _group.push(input));\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction remove() {\n\t\t_inputs.forEach((input) => _group.splice(_group.indexOf(input), 1));\n\t}\n\treturn {\n\t\t/* update */ u(new_indexes) {\n\t\t\tindexes = new_indexes;\n\t\t\tconst new_group = get_binding_group(group);\n\t\t\tif (new_group !== _group) {\n\t\t\t\tremove();\n\t\t\t\t_group = new_group;\n\t\t\t\tpush();\n\t\t\t}\n\t\t},\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\tpush();\n\t\t},\n\t\t/* remove */ r: remove\n\t};\n}\n\n/** @returns {number} */\nexport function to_number(value) {\n\treturn value === '' ? null : +value;\n}\n\n/** @returns {any[]} */\nexport function time_ranges_to_array(ranges) {\n\tconst array = [];\n\tfor (let i = 0; i < ranges.length; i += 1) {\n\t\tarray.push({ start: ranges.start(i), end: ranges.end(i) });\n\t}\n\treturn array;\n}\n\n/**\n * @param {Element} element\n * @returns {ChildNode[]}\n */\nexport function children(element) {\n\treturn Array.from(element.childNodes);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {void}\n */\nfunction init_claim_info(nodes) {\n\tif (nodes.claim_info === undefined) {\n\t\tnodes.claim_info = { last_index: 0, total_claimed: 0 };\n\t}\n}\n\n/**\n * @template {ChildNodeEx} R\n * @param {ChildNodeArray} nodes\n * @param {(node: ChildNodeEx) => node is R} predicate\n * @param {(node: ChildNodeEx) => ChildNodeEx | undefined} process_node\n * @param {() => R} create_node\n * @param {boolean} dont_update_last_index\n * @returns {R}\n */\nfunction claim_node(nodes, predicate, process_node, create_node, dont_update_last_index = false) {\n\t// Try to find nodes in an order such that we lengthen the longest increasing subsequence\n\tinit_claim_info(nodes);\n\tconst result_node = (() => {\n\t\t// We first try to find an element after the previous one\n\t\tfor (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// Otherwise, we try to find one before\n\t\t// We iterate in reverse so that we don't go too far back\n\t\tfor (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t} else if (replacement === undefined) {\n\t\t\t\t\t// Since we spliced before the last_index, we decrease it\n\t\t\t\t\tnodes.claim_info.last_index--;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// If we can't find any matching node, we create a new one\n\t\treturn create_node();\n\t})();\n\tresult_node.claim_order = nodes.claim_info.total_claimed;\n\tnodes.claim_info.total_claimed += 1;\n\treturn result_node;\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @param {(name: string) => Element | SVGElement} create_element\n * @returns {Element | SVGElement}\n */\nfunction claim_element_base(nodes, name, attributes, create_element) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Element | SVGElement} */\n\t\t(node) => node.nodeName === name,\n\t\t/** @param {Element} node */\n\t\t(node) => {\n\t\t\tconst remove = [];\n\t\t\tfor (let j = 0; j < node.attributes.length; j++) {\n\t\t\t\tconst attribute = node.attributes[j];\n\t\t\t\tif (!attributes[attribute.name]) {\n\t\t\t\t\tremove.push(attribute.name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tremove.forEach((v) => node.removeAttribute(v));\n\t\t\treturn undefined;\n\t\t},\n\t\t() => create_element(name)\n\t);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_svg_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, svg_element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Text}\n */\nexport function claim_text(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Text} */\n\t\t(node) => node.nodeType === 3,\n\t\t/** @param {Text} node */\n\t\t(node) => {\n\t\t\tconst data_str = '' + data;\n\t\t\tif (node.data.startsWith(data_str)) {\n\t\t\t\tif (node.data.length !== data_str.length) {\n\t\t\t\t\treturn node.splitText(data_str.length);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode.data = data_str;\n\t\t\t}\n\t\t},\n\t\t() => text(data),\n\t\ttrue // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n\t);\n}\n\n/**\n * @returns {Text} */\nexport function claim_space(nodes) {\n\treturn claim_text(nodes, ' ');\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Comment}\n */\nexport function claim_comment(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Comment} */\n\t\t(node) => node.nodeType === 8,\n\t\t/** @param {Comment} node */\n\t\t(node) => {\n\t\t\tnode.data = '' + data;\n\t\t\treturn undefined;\n\t\t},\n\t\t() => comment(data),\n\t\ttrue\n\t);\n}\n\nfunction get_comment_idx(nodes, text, start) {\n\tfor (let i = start; i < nodes.length; i += 1) {\n\t\tconst node = nodes[i];\n\t\tif (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * @param {boolean} is_svg\n * @returns {HtmlTagHydration}\n */\nexport function claim_html_tag(nodes, is_svg) {\n\t// find html opening tag\n\tconst start_index = get_comment_idx(nodes, 'HTML_TAG_START', 0);\n\tconst end_index = get_comment_idx(nodes, 'HTML_TAG_END', start_index + 1);\n\tif (start_index === -1 || end_index === -1) {\n\t\treturn new HtmlTagHydration(is_svg);\n\t}\n\n\tinit_claim_info(nodes);\n\tconst html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n\tdetach(html_tag_nodes[0]);\n\tdetach(html_tag_nodes[html_tag_nodes.length - 1]);\n\tconst claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n\tif (claimed_nodes.length === 0) {\n\t\treturn new HtmlTagHydration(is_svg);\n\t}\n\tfor (const n of claimed_nodes) {\n\t\tn.claim_order = nodes.claim_info.total_claimed;\n\t\tnodes.claim_info.total_claimed += 1;\n\t}\n\treturn new HtmlTagHydration(is_svg, claimed_nodes);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data(text, data) {\n\tdata = '' + data;\n\tif (text.data === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data_contenteditable(text, data) {\n\tdata = '' + data;\n\tif (text.wholeText === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @param {string} attr_value\n * @returns {void}\n */\nexport function set_data_maybe_contenteditable(text, data, attr_value) {\n\tif (~contenteditable_truthy_values.indexOf(attr_value)) {\n\t\tset_data_contenteditable(text, data);\n\t} else {\n\t\tset_data(text, data);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_input_value(input, value) {\n\tinput.value = value == null ? '' : value;\n}\n\n/**\n * @returns {void} */\nexport function set_input_type(input, type) {\n\ttry {\n\t\tinput.type = type;\n\t} catch (e) {\n\t\t// do nothing\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_style(node, key, value, important) {\n\tif (value == null) {\n\t\tnode.style.removeProperty(key);\n\t} else {\n\t\tnode.style.setProperty(key, value, important ? 'important' : '');\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_option(select, value, mounting) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\tif (option.__value === value) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_options(select, value) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\toption.selected = ~value.indexOf(option.__value);\n\t}\n}\n\nexport function select_value(select) {\n\tconst selected_option = select.querySelector(':checked');\n\treturn selected_option && selected_option.__value;\n}\n\nexport function select_multiple_value(select) {\n\treturn [].map.call(select.querySelectorAll(':checked'), (option) => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\n\n/**\n * @type {boolean} */\nlet crossorigin;\n\n/**\n * @returns {boolean} */\nexport function is_crossorigin() {\n\tif (crossorigin === undefined) {\n\t\tcrossorigin = false;\n\t\ttry {\n\t\t\tif (typeof window !== 'undefined' && window.parent) {\n\t\t\t\tvoid window.parent.document;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tcrossorigin = true;\n\t\t}\n\t}\n\treturn crossorigin;\n}\n\n/**\n * @param {HTMLElement} node\n * @param {() => void} fn\n * @returns {() => void}\n */\nexport function add_iframe_resize_listener(node, fn) {\n\tconst computed_style = getComputedStyle(node);\n\tif (computed_style.position === 'static') {\n\t\tnode.style.position = 'relative';\n\t}\n\tconst iframe = element('iframe');\n\tiframe.setAttribute(\n\t\t'style',\n\t\t'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n\t\t\t'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;'\n\t);\n\tiframe.setAttribute('aria-hidden', 'true');\n\tiframe.tabIndex = -1;\n\tconst crossorigin = is_crossorigin();\n\n\t/**\n\t * @type {() => void}\n\t */\n\tlet unsubscribe;\n\tif (crossorigin) {\n\t\tiframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n\t\tunsubscribe = listen(\n\t\t\twindow,\n\t\t\t'message',\n\t\t\t/** @param {MessageEvent} event */ (event) => {\n\t\t\t\tif (event.source === iframe.contentWindow) fn();\n\t\t\t}\n\t\t);\n\t} else {\n\t\tiframe.src = 'about:blank';\n\t\tiframe.onload = () => {\n\t\t\tunsubscribe = listen(iframe.contentWindow, 'resize', fn);\n\t\t\t// make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n\t\t\t// see https://github.com/sveltejs/svelte/issues/4233\n\t\t\tfn();\n\t\t};\n\t}\n\tappend(node, iframe);\n\treturn () => {\n\t\tif (crossorigin) {\n\t\t\tunsubscribe();\n\t\t} else if (unsubscribe && iframe.contentWindow) {\n\t\t\tunsubscribe();\n\t\t}\n\t\tdetach(iframe);\n\t};\n}\nexport const resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'content-box'\n});\nexport const resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'border-box'\n});\nexport const resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton(\n\t{ box: 'device-pixel-content-box' }\n);\nexport { ResizeObserverSingleton };\n\n/**\n * @returns {void} */\nexport function toggle_class(element, name, toggle) {\n\t// The `!!` is required because an `undefined` flag means flipping the current state.\n\telement.classList.toggle(name, !!toggle);\n}\n\n/**\n * @template T\n * @param {string} type\n * @param {T} [detail]\n * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]\n * @returns {CustomEvent<T>}\n */\nexport function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n\treturn new CustomEvent(type, { detail, bubbles, cancelable });\n}\n\n/**\n * @param {string} selector\n * @param {HTMLElement} parent\n * @returns {ChildNodeArray}\n */\nexport function query_selector_all(selector, parent = document.body) {\n\treturn Array.from(parent.querySelectorAll(selector));\n}\n\n/**\n * @param {string} nodeId\n * @param {HTMLElement} head\n * @returns {any[]}\n */\nexport function head_selector(nodeId, head) {\n\tconst result = [];\n\tlet started = 0;\n\tfor (const node of head.childNodes) {\n\t\tif (node.nodeType === 8 /* comment node */) {\n\t\t\tconst comment = node.textContent.trim();\n\t\t\tif (comment === `HEAD_${nodeId}_END`) {\n\t\t\t\tstarted -= 1;\n\t\t\t\tresult.push(node);\n\t\t\t} else if (comment === `HEAD_${nodeId}_START`) {\n\t\t\t\tstarted += 1;\n\t\t\t\tresult.push(node);\n\t\t\t}\n\t\t} else if (started > 0) {\n\t\t\tresult.push(node);\n\t\t}\n\t}\n\treturn result;\n}\n/** */\nexport class HtmlTag {\n\t/**\n\t * @private\n\t * @default false\n\t */\n\tis_svg = false;\n\t/** parent for creating node */\n\te = undefined;\n\t/** html tag nodes */\n\tn = undefined;\n\t/** target */\n\tt = undefined;\n\t/** anchor */\n\ta = undefined;\n\tconstructor(is_svg = false) {\n\t\tthis.is_svg = is_svg;\n\t\tthis.e = this.n = null;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tthis.h(html);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @param {HTMLElement | SVGElement} target\n\t * @param {HTMLElement | SVGElement} anchor\n\t * @returns {void}\n\t */\n\tm(html, target, anchor = null) {\n\t\tif (!this.e) {\n\t\t\tif (this.is_svg)\n\t\t\t\tthis.e = svg_element(/** @type {keyof SVGElementTagNameMap} */ (target.nodeName));\n\t\t\t/** #7364  target for <template> may be provided as #document-fragment(11) */ else\n\t\t\t\tthis.e = element(\n\t\t\t\t\t/** @type {keyof HTMLElementTagNameMap} */ (\n\t\t\t\t\t\ttarget.nodeType === 11 ? 'TEMPLATE' : target.nodeName\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\tthis.t =\n\t\t\t\ttarget.tagName !== 'TEMPLATE'\n\t\t\t\t\t? target\n\t\t\t\t\t: /** @type {HTMLTemplateElement} */ (target).content;\n\t\t\tthis.c(html);\n\t\t}\n\t\tthis.i(anchor);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\th(html) {\n\t\tthis.e.innerHTML = html;\n\t\tthis.n = Array.from(\n\t\t\tthis.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes\n\t\t);\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert(this.t, this.n[i], anchor);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tp(html) {\n\t\tthis.d();\n\t\tthis.h(html);\n\t\tthis.i(this.a);\n\t}\n\n\t/**\n\t * @returns {void} */\n\td() {\n\t\tthis.n.forEach(detach);\n\t}\n}\n\nexport class HtmlTagHydration extends HtmlTag {\n\t/** @type {Element[]} hydration claimed nodes */\n\tl = undefined;\n\n\tconstructor(is_svg = false, claimed_nodes) {\n\t\tsuper(is_svg);\n\t\tthis.e = this.n = null;\n\t\tthis.l = claimed_nodes;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tif (this.l) {\n\t\t\tthis.n = this.l;\n\t\t} else {\n\t\t\tsuper.c(html);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert_hydration(this.t, this.n[i], anchor);\n\t\t}\n\t}\n}\n\n/**\n * @param {NamedNodeMap} attributes\n * @returns {{}}\n */\nexport function attribute_to_object(attributes) {\n\tconst result = {};\n\tfor (const attribute of attributes) {\n\t\tresult[attribute.name] = attribute.value;\n\t}\n\treturn result;\n}\n\nconst escaped = {\n\t'\"': '&quot;',\n\t'&': '&amp;',\n\t'<': '&lt;'\n};\n\nconst regex_attribute_characters_to_escape = /[\"&<]/g;\n\n/**\n * Note that the attribute itself should be surrounded in double quotes\n * @param {any} attribute\n */\nfunction escape_attribute(attribute) {\n\treturn String(attribute).replace(regex_attribute_characters_to_escape, (match) => escaped[match]);\n}\n\n/**\n * @param {Record<string, string>} attributes\n */\nexport function stringify_spread(attributes) {\n\tlet str = ' ';\n\tfor (const key in attributes) {\n\t\tif (attributes[key] != null) {\n\t\t\tstr += `${key}=\"${escape_attribute(attributes[key])}\" `;\n\t\t}\n\t}\n\n\treturn str;\n}\n\n/**\n * @param {HTMLElement} element\n * @returns {{}}\n */\nexport function get_custom_elements_slots(element) {\n\tconst result = {};\n\telement.childNodes.forEach(\n\t\t/** @param {Element} node */ (node) => {\n\t\t\tresult[node.slot || 'default'] = true;\n\t\t}\n\t);\n\treturn result;\n}\n\nexport function construct_svelte_component(component, props) {\n\treturn new component(props);\n}\n\n/**\n * @typedef {Node & {\n * \tclaim_order?: number;\n * \thydrate_init?: true;\n * \tactual_end_child?: NodeEx;\n * \tchildNodes: NodeListOf<NodeEx>;\n * }} NodeEx\n */\n\n/** @typedef {ChildNode & NodeEx} ChildNodeEx */\n\n/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */\n\n/**\n * @typedef {ChildNodeEx[] & {\n * \tclaim_info?: {\n * \t\tlast_index: number;\n * \t\ttotal_claimed: number;\n * \t};\n * }} ChildNodeArray\n */\n","import { append_empty_stylesheet, detach, get_root_for_style } from './dom.js';\nimport { raf } from './environment.js';\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\n/** @type {Map<Document | ShadowRoot, import('./private.d.ts').StyleInformation>} */\nconst managed_styles = new Map();\n\nlet active = 0;\n\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\n/**\n * @param {string} str\n * @returns {number}\n */\nfunction hash(str) {\n\tlet hash = 5381;\n\tlet i = str.length;\n\twhile (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n\treturn hash >>> 0;\n}\n\n/**\n * @param {Document | ShadowRoot} doc\n * @param {Element & ElementCSSInlineStyle} node\n * @returns {{ stylesheet: any; rules: {}; }}\n */\nfunction create_style_information(doc, node) {\n\tconst info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n\tmanaged_styles.set(doc, info);\n\treturn info;\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {number} a\n * @param {number} b\n * @param {number} duration\n * @param {number} delay\n * @param {(t: number) => number} ease\n * @param {(t: number, u: number) => string} fn\n * @param {number} uid\n * @returns {string}\n */\nexport function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n\tconst step = 16.666 / duration;\n\tlet keyframes = '{\\n';\n\tfor (let p = 0; p <= 1; p += step) {\n\t\tconst t = a + (b - a) * ease(p);\n\t\tkeyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n\t}\n\tconst rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n\tconst name = `__svelte_${hash(rule)}_${uid}`;\n\tconst doc = get_root_for_style(node);\n\tconst { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n\tif (!rules[name]) {\n\t\trules[name] = true;\n\t\tstylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n\t}\n\tconst animation = node.style.animation || '';\n\tnode.style.animation = `${\n\t\tanimation ? `${animation}, ` : ''\n\t}${name} ${duration}ms linear ${delay}ms 1 both`;\n\tactive += 1;\n\treturn name;\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {string} [name]\n * @returns {void}\n */\nexport function delete_rule(node, name) {\n\tconst previous = (node.style.animation || '').split(', ');\n\tconst next = previous.filter(\n\t\tname\n\t\t\t? (anim) => anim.indexOf(name) < 0 // remove specific animation\n\t\t\t: (anim) => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n\t);\n\tconst deleted = previous.length - next.length;\n\tif (deleted) {\n\t\tnode.style.animation = next.join(', ');\n\t\tactive -= deleted;\n\t\tif (!active) clear_rules();\n\t}\n}\n\n/** @returns {void} */\nexport function clear_rules() {\n\traf(() => {\n\t\tif (active) return;\n\t\tmanaged_styles.forEach((info) => {\n\t\t\tconst { ownerNode } = info.stylesheet;\n\t\t\t// there is no ownerNode if it runs on jsdom.\n\t\t\tif (ownerNode) detach(ownerNode);\n\t\t});\n\t\tmanaged_styles.clear();\n\t});\n}\n","import { identity as linear, is_function, noop, run_all } from './utils.js';\nimport { now } from './environment.js';\nimport { loop } from './loop.js';\nimport { create_rule, delete_rule } from './style_manager.js';\nimport { custom_event } from './dom.js';\nimport { add_render_callback } from './scheduler.js';\n\n/**\n * @type {Promise<void> | null}\n */\nlet promise;\n\n/**\n * @returns {Promise<void>}\n */\nfunction wait() {\n\tif (!promise) {\n\t\tpromise = Promise.resolve();\n\t\tpromise.then(() => {\n\t\t\tpromise = null;\n\t\t});\n\t}\n\treturn promise;\n}\n\n/**\n * @param {Element} node\n * @param {INTRO | OUTRO | boolean} direction\n * @param {'start' | 'end'} kind\n * @returns {void}\n */\nfunction dispatch(node, direction, kind) {\n\tnode.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\n\nconst outroing = new Set();\n\n/**\n * @type {Outro}\n */\nlet outros;\n\n/**\n * @returns {void} */\nexport function group_outros() {\n\toutros = {\n\t\tr: 0,\n\t\tc: [],\n\t\tp: outros // parent group\n\t};\n}\n\n/**\n * @returns {void} */\nexport function check_outros() {\n\tif (!outros.r) {\n\t\trun_all(outros.c);\n\t}\n\toutros = outros.p;\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} [local]\n * @returns {void}\n */\nexport function transition_in(block, local) {\n\tif (block && block.i) {\n\t\toutroing.delete(block);\n\t\tblock.i(local);\n\t}\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} local\n * @param {0 | 1} [detach]\n * @param {() => void} [callback]\n * @returns {void}\n */\nexport function transition_out(block, local, detach, callback) {\n\tif (block && block.o) {\n\t\tif (outroing.has(block)) return;\n\t\toutroing.add(block);\n\t\toutros.c.push(() => {\n\t\t\toutroing.delete(block);\n\t\t\tif (callback) {\n\t\t\t\tif (detach) block.d(1);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t});\n\t\tblock.o(local);\n\t} else if (callback) {\n\t\tcallback();\n\t}\n}\n\n/**\n * @type {import('../transition/public.js').TransitionConfig}\n */\nconst null_transition = { duration: 0 };\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ start(): void; invalidate(): void; end(): void; }}\n */\nexport function create_in_transition(node, fn, params) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'in' };\n\tlet config = fn(node, params, options);\n\tlet running = false;\n\tlet animation_name;\n\tlet task;\n\tlet uid = 0;\n\n\t/**\n\t * @returns {void} */\n\tfunction cleanup() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\t\tif (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n\t\ttick(0, 1);\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tif (task) task.abort();\n\t\trunning = true;\n\t\tadd_render_callback(() => dispatch(node, true, 'start'));\n\t\ttask = loop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(1, 0);\n\t\t\t\t\tdispatch(node, true, 'end');\n\t\t\t\t\tcleanup();\n\t\t\t\t\treturn (running = false);\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\tlet started = false;\n\treturn {\n\t\tstart() {\n\t\t\tif (started) return;\n\t\t\tstarted = true;\n\t\t\tdelete_rule(node);\n\t\t\tif (is_function(config)) {\n\t\t\t\tconfig = config(options);\n\t\t\t\twait().then(go);\n\t\t\t} else {\n\t\t\t\tgo();\n\t\t\t}\n\t\t},\n\t\tinvalidate() {\n\t\t\tstarted = false;\n\t\t},\n\t\tend() {\n\t\t\tif (running) {\n\t\t\t\tcleanup();\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ end(reset: any): void; }}\n */\nexport function create_out_transition(node, fn, params) {\n\t/** @type {TransitionOptions} */\n\tconst options = { direction: 'out' };\n\tlet config = fn(node, params, options);\n\tlet running = true;\n\tlet animation_name;\n\tconst group = outros;\n\tgroup.r += 1;\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\tif (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tadd_render_callback(() => dispatch(node, false, 'start'));\n\n\t\tif ('inert' in node) {\n\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\tnode.inert = true;\n\t\t}\n\n\t\tloop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(0, 1);\n\t\t\t\t\tdispatch(node, false, 'end');\n\t\t\t\t\tif (!--group.r) {\n\t\t\t\t\t\t// this will result in `end()` being called,\n\t\t\t\t\t\t// so we don't need to clean up here\n\t\t\t\t\t\trun_all(group.c);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(1 - t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\n\tif (is_function(config)) {\n\t\twait().then(() => {\n\t\t\t// @ts-ignore\n\t\t\tconfig = config(options);\n\t\t\tgo();\n\t\t});\n\t} else {\n\t\tgo();\n\t}\n\n\treturn {\n\t\tend(reset) {\n\t\t\tif (reset && 'inert' in node) {\n\t\t\t\tnode.inert = original_inert_value;\n\t\t\t}\n\t\t\tif (reset && config.tick) {\n\t\t\t\tconfig.tick(1, 0);\n\t\t\t}\n\t\t\tif (running) {\n\t\t\t\tif (animation_name) delete_rule(node, animation_name);\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @param {boolean} intro\n * @returns {{ run(b: 0 | 1): void; end(): void; }}\n */\nexport function create_bidirectional_transition(node, fn, params, intro) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'both' };\n\tlet config = fn(node, params, options);\n\tlet t = intro ? 0 : 1;\n\n\t/**\n\t * @type {Program | null} */\n\tlet running_program = null;\n\n\t/**\n\t * @type {PendingProgram | null} */\n\tlet pending_program = null;\n\tlet animation_name = null;\n\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction clear_animation() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @param {PendingProgram} program\n\t * @param {number} duration\n\t * @returns {Program}\n\t */\n\tfunction init(program, duration) {\n\t\tconst d = /** @type {Program['d']} */ (program.b - t);\n\t\tduration *= Math.abs(d);\n\t\treturn {\n\t\t\ta: t,\n\t\t\tb: program.b,\n\t\t\td,\n\t\t\tduration,\n\t\t\tstart: program.start,\n\t\t\tend: program.start + duration,\n\t\t\tgroup: program.group\n\t\t};\n\t}\n\n\t/**\n\t * @param {INTRO | OUTRO} b\n\t * @returns {void}\n\t */\n\tfunction go(b) {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\t/**\n\t\t * @type {PendingProgram} */\n\t\tconst program = {\n\t\t\tstart: now() + delay,\n\t\t\tb\n\t\t};\n\n\t\tif (!b) {\n\t\t\t// @ts-ignore todo: improve typings\n\t\t\tprogram.group = outros;\n\t\t\toutros.r += 1;\n\t\t}\n\n\t\tif ('inert' in node) {\n\t\t\tif (b) {\n\t\t\t\tif (original_inert_value !== undefined) {\n\t\t\t\t\t// aborted/reversed outro — restore previous inert value\n\t\t\t\t\tnode.inert = original_inert_value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\t\tnode.inert = true;\n\t\t\t}\n\t\t}\n\n\t\tif (running_program || pending_program) {\n\t\t\tpending_program = program;\n\t\t} else {\n\t\t\t// if this is an intro, and there's a delay, we need to do\n\t\t\t// an initial tick and/or apply CSS animation immediately\n\t\t\tif (css) {\n\t\t\t\tclear_animation();\n\t\t\t\tanimation_name = create_rule(node, t, b, duration, delay, easing, css);\n\t\t\t}\n\t\t\tif (b) tick(0, 1);\n\t\t\trunning_program = init(program, duration);\n\t\t\tadd_render_callback(() => dispatch(node, b, 'start'));\n\t\t\tloop((now) => {\n\t\t\t\tif (pending_program && now > pending_program.start) {\n\t\t\t\t\trunning_program = init(pending_program, duration);\n\t\t\t\t\tpending_program = null;\n\t\t\t\t\tdispatch(node, running_program.b, 'start');\n\t\t\t\t\tif (css) {\n\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\tanimation_name = create_rule(\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\tt,\n\t\t\t\t\t\t\trunning_program.b,\n\t\t\t\t\t\t\trunning_program.duration,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\teasing,\n\t\t\t\t\t\t\tconfig.css\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (running_program) {\n\t\t\t\t\tif (now >= running_program.end) {\n\t\t\t\t\t\ttick((t = running_program.b), 1 - t);\n\t\t\t\t\t\tdispatch(node, running_program.b, 'end');\n\t\t\t\t\t\tif (!pending_program) {\n\t\t\t\t\t\t\t// we're done\n\t\t\t\t\t\t\tif (running_program.b) {\n\t\t\t\t\t\t\t\t// intro — we can tidy up immediately\n\t\t\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// outro — needs to be coordinated\n\t\t\t\t\t\t\t\tif (!--running_program.group.r) run_all(running_program.group.c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trunning_program = null;\n\t\t\t\t\t} else if (now >= running_program.start) {\n\t\t\t\t\t\tconst p = now - running_program.start;\n\t\t\t\t\t\tt = running_program.a + running_program.d * easing(p / running_program.duration);\n\t\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn !!(running_program || pending_program);\n\t\t\t});\n\t\t}\n\t}\n\treturn {\n\t\trun(b) {\n\t\t\tif (is_function(config)) {\n\t\t\t\twait().then(() => {\n\t\t\t\t\tconst opts = { direction: b ? 'in' : 'out' };\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconfig = config(opts);\n\t\t\t\t\tgo(b);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tgo(b);\n\t\t\t}\n\t\t},\n\t\tend() {\n\t\t\tclear_animation();\n\t\t\trunning_program = pending_program = null;\n\t\t}\n\t};\n}\n\n/** @typedef {1} INTRO */\n/** @typedef {0} OUTRO */\n/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */\n/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */\n\n/**\n * @typedef {Object} Outro\n * @property {number} r\n * @property {Function[]} c\n * @property {Object} p\n */\n\n/**\n * @typedef {Object} PendingProgram\n * @property {number} start\n * @property {INTRO|OUTRO} b\n * @property {Outro} [group]\n */\n\n/**\n * @typedef {Object} Program\n * @property {number} a\n * @property {INTRO|OUTRO} b\n * @property {1|-1} d\n * @property {number} duration\n * @property {number} start\n * @property {number} end\n * @property {Outro} [group]\n */\n","import {\n\tadd_render_callback,\n\tflush,\n\tflush_render_callbacks,\n\tschedule_update,\n\tdirty_components\n} from './scheduler.js';\nimport { current_component, set_current_component } from './lifecycle.js';\nimport { blank_object, is_empty, is_function, run, run_all, noop } from './utils.js';\nimport {\n\tchildren,\n\tdetach,\n\tstart_hydrating,\n\tend_hydrating,\n\tget_custom_elements_slots,\n\tinsert,\n\telement,\n\tattr\n} from './dom.js';\nimport { transition_in } from './transitions.js';\n\n/** @returns {void} */\nexport function bind(component, name, callback) {\n\tconst index = component.$$.props[name];\n\tif (index !== undefined) {\n\t\tcomponent.$$.bound[index] = callback;\n\t\tcallback(component.$$.ctx[index]);\n\t}\n}\n\n/** @returns {void} */\nexport function create_component(block) {\n\tblock && block.c();\n}\n\n/** @returns {void} */\nexport function claim_component(block, parent_nodes) {\n\tblock && block.l(parent_nodes);\n}\n\n/** @returns {void} */\nexport function mount_component(component, target, anchor) {\n\tconst { fragment, after_update } = component.$$;\n\tfragment && fragment.m(target, anchor);\n\t// onMount happens before the initial afterUpdate\n\tadd_render_callback(() => {\n\t\tconst new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n\t\t// if the component was destroyed immediately\n\t\t// it will update the `$$.on_destroy` reference to `null`.\n\t\t// the destructured on_destroy may still reference to the old array\n\t\tif (component.$$.on_destroy) {\n\t\t\tcomponent.$$.on_destroy.push(...new_on_destroy);\n\t\t} else {\n\t\t\t// Edge case - component was destroyed immediately,\n\t\t\t// most likely as a result of a binding initialising\n\t\t\trun_all(new_on_destroy);\n\t\t}\n\t\tcomponent.$$.on_mount = [];\n\t});\n\tafter_update.forEach(add_render_callback);\n}\n\n/** @returns {void} */\nexport function destroy_component(component, detaching) {\n\tconst $$ = component.$$;\n\tif ($$.fragment !== null) {\n\t\tflush_render_callbacks($$.after_update);\n\t\trun_all($$.on_destroy);\n\t\t$$.fragment && $$.fragment.d(detaching);\n\t\t// TODO null out other refs, including component.$$ (but need to\n\t\t// preserve final state?)\n\t\t$$.on_destroy = $$.fragment = null;\n\t\t$$.ctx = [];\n\t}\n}\n\n/** @returns {void} */\nfunction make_dirty(component, i) {\n\tif (component.$$.dirty[0] === -1) {\n\t\tdirty_components.push(component);\n\t\tschedule_update();\n\t\tcomponent.$$.dirty.fill(0);\n\t}\n\tcomponent.$$.dirty[(i / 31) | 0] |= 1 << i % 31;\n}\n\n// TODO: Document the other params\n/**\n * @param {SvelteComponent} component\n * @param {import('./public.js').ComponentConstructorOptions} options\n *\n * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.\n * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.\n * This will be the `add_css` function from the compiled component.\n *\n * @returns {void}\n */\nexport function init(\n\tcomponent,\n\toptions,\n\tinstance,\n\tcreate_fragment,\n\tnot_equal,\n\tprops,\n\tappend_styles = null,\n\tdirty = [-1]\n) {\n\tconst parent_component = current_component;\n\tset_current_component(component);\n\t/** @type {import('./private.js').T$$} */\n\tconst $$ = (component.$$ = {\n\t\tfragment: null,\n\t\tctx: [],\n\t\t// state\n\t\tprops,\n\t\tupdate: noop,\n\t\tnot_equal,\n\t\tbound: blank_object(),\n\t\t// lifecycle\n\t\ton_mount: [],\n\t\ton_destroy: [],\n\t\ton_disconnect: [],\n\t\tbefore_update: [],\n\t\tafter_update: [],\n\t\tcontext: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n\t\t// everything else\n\t\tcallbacks: blank_object(),\n\t\tdirty,\n\t\tskip_bound: false,\n\t\troot: options.target || parent_component.$$.root\n\t});\n\tappend_styles && append_styles($$.root);\n\tlet ready = false;\n\t$$.ctx = instance\n\t\t? instance(component, options.props || {}, (i, ret, ...rest) => {\n\t\t\t\tconst value = rest.length ? rest[0] : ret;\n\t\t\t\tif ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {\n\t\t\t\t\tif (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n\t\t\t\t\tif (ready) make_dirty(component, i);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t  })\n\t\t: [];\n\t$$.update();\n\tready = true;\n\trun_all($$.before_update);\n\t// `false` as a special case of no DOM component\n\t$$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n\tif (options.target) {\n\t\tif (options.hydrate) {\n\t\t\tstart_hydrating();\n\t\t\t// TODO: what is the correct type here?\n\t\t\t// @ts-expect-error\n\t\t\tconst nodes = children(options.target);\n\t\t\t$$.fragment && $$.fragment.l(nodes);\n\t\t\tnodes.forEach(detach);\n\t\t} else {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\t$$.fragment && $$.fragment.c();\n\t\t}\n\t\tif (options.intro) transition_in(component.$$.fragment);\n\t\tmount_component(component, options.target, options.anchor);\n\t\tend_hydrating();\n\t\tflush();\n\t}\n\tset_current_component(parent_component);\n}\n\nexport let SvelteElement;\n\nif (typeof HTMLElement === 'function') {\n\tSvelteElement = class extends HTMLElement {\n\t\t/** The Svelte component constructor */\n\t\t$$ctor;\n\t\t/** Slots */\n\t\t$$s;\n\t\t/** The Svelte component instance */\n\t\t$$c;\n\t\t/** Whether or not the custom element is connected */\n\t\t$$cn = false;\n\t\t/** Component props data */\n\t\t$$d = {};\n\t\t/** `true` if currently in the process of reflecting component props back to attributes */\n\t\t$$r = false;\n\t\t/** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */\n\t\t$$p_d = {};\n\t\t/** @type {Record<string, Function[]>} Event listeners */\n\t\t$$l = {};\n\t\t/** @type {Map<Function, Function>} Event listener unsubscribe functions */\n\t\t$$l_u = new Map();\n\n\t\tconstructor($$componentCtor, $$slots, use_shadow_dom) {\n\t\t\tsuper();\n\t\t\tthis.$$ctor = $$componentCtor;\n\t\t\tthis.$$s = $$slots;\n\t\t\tif (use_shadow_dom) {\n\t\t\t\tthis.attachShadow({ mode: 'open' });\n\t\t\t}\n\t\t}\n\n\t\taddEventListener(type, listener, options) {\n\t\t\t// We can't determine upfront if the event is a custom event or not, so we have to\n\t\t\t// listen to both. If someone uses a custom event with the same name as a regular\n\t\t\t// browser event, this fires twice - we can't avoid that.\n\t\t\tthis.$$l[type] = this.$$l[type] || [];\n\t\t\tthis.$$l[type].push(listener);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t}\n\t\t\tsuper.addEventListener(type, listener, options);\n\t\t}\n\n\t\tremoveEventListener(type, listener, options) {\n\t\t\tsuper.removeEventListener(type, listener, options);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$l_u.get(listener);\n\t\t\t\tif (unsub) {\n\t\t\t\t\tunsub();\n\t\t\t\t\tthis.$$l_u.delete(listener);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tasync connectedCallback() {\n\t\t\tthis.$$cn = true;\n\t\t\tif (!this.$$c) {\n\t\t\t\t// We wait one tick to let possible child slot elements be created/mounted\n\t\t\t\tawait Promise.resolve();\n\t\t\t\tif (!this.$$cn || this.$$c) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfunction create_slot(name) {\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tlet node;\n\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\tc: function create() {\n\t\t\t\t\t\t\t\tnode = element('slot');\n\t\t\t\t\t\t\t\tif (name !== 'default') {\n\t\t\t\t\t\t\t\t\tattr(node, 'name', name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {HTMLElement} target\n\t\t\t\t\t\t\t * @param {HTMLElement} [anchor]\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tm: function mount(target, anchor) {\n\t\t\t\t\t\t\t\tinsert(target, node, anchor);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\td: function destroy(detaching) {\n\t\t\t\t\t\t\t\tif (detaching) {\n\t\t\t\t\t\t\t\t\tdetach(node);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tconst $$slots = {};\n\t\t\t\tconst existing_slots = get_custom_elements_slots(this);\n\t\t\t\tfor (const name of this.$$s) {\n\t\t\t\t\tif (name in existing_slots) {\n\t\t\t\t\t\t$$slots[name] = [create_slot(name)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const attribute of this.attributes) {\n\t\t\t\t\t// this.$$data takes precedence over this.attributes\n\t\t\t\t\tconst name = this.$$g_p(attribute.name);\n\t\t\t\t\tif (!(name in this.$$d)) {\n\t\t\t\t\t\tthis.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Port over props that were set programmatically before ce was initialized\n\t\t\t\tfor (const key in this.$$p_d) {\n\t\t\t\t\tif (!(key in this.$$d) && this[key] !== undefined) {\n\t\t\t\t\t\tthis.$$d[key] = this[key]; // don't transform, these were set through JavaScript\n\t\t\t\t\t\tdelete this[key]; // remove the property that shadows the getter/setter\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$c = new this.$$ctor({\n\t\t\t\t\ttarget: this.shadowRoot || this,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...this.$$d,\n\t\t\t\t\t\t$$slots,\n\t\t\t\t\t\t$$scope: {\n\t\t\t\t\t\t\tctx: []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Reflect component props as attributes\n\t\t\t\tconst reflect_attributes = () => {\n\t\t\t\t\tthis.$$r = true;\n\t\t\t\t\tfor (const key in this.$$p_d) {\n\t\t\t\t\t\tthis.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];\n\t\t\t\t\t\tif (this.$$p_d[key].reflect) {\n\t\t\t\t\t\t\tconst attribute_value = get_custom_element_value(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tthis.$$d[key],\n\t\t\t\t\t\t\t\tthis.$$p_d,\n\t\t\t\t\t\t\t\t'toAttribute'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (attribute_value == null) {\n\t\t\t\t\t\t\t\tthis.removeAttribute(this.$$p_d[key].attribute || key);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.setAttribute(this.$$p_d[key].attribute || key, attribute_value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.$$r = false;\n\t\t\t\t};\n\t\t\t\tthis.$$c.$$.after_update.push(reflect_attributes);\n\t\t\t\treflect_attributes(); // once initially because after_update is added too late for first render\n\n\t\t\t\tfor (const type in this.$$l) {\n\t\t\t\t\tfor (const listener of this.$$l[type]) {\n\t\t\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$l = {};\n\t\t\t}\n\t\t}\n\n\t\t// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte\n\t\t// and setting attributes through setAttribute etc, this is helpful\n\t\tattributeChangedCallback(attr, _oldValue, newValue) {\n\t\t\tif (this.$$r) return;\n\t\t\tattr = this.$$g_p(attr);\n\t\t\tthis.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp');\n\t\t\tthis.$$c?.$set({ [attr]: this.$$d[attr] });\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.$$cn = false;\n\t\t\t// In a microtask, because this could be a move within the DOM\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tif (!this.$$cn && this.$$c) {\n\t\t\t\t\tthis.$$c.$destroy();\n\t\t\t\t\tthis.$$c = undefined;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t$$g_p(attribute_name) {\n\t\t\treturn (\n\t\t\t\tObject.keys(this.$$p_d).find(\n\t\t\t\t\t(key) =>\n\t\t\t\t\t\tthis.$$p_d[key].attribute === attribute_name ||\n\t\t\t\t\t\t(!this.$$p_d[key].attribute && key.toLowerCase() === attribute_name)\n\t\t\t\t) || attribute_name\n\t\t\t);\n\t\t}\n\t};\n}\n\n/**\n * @param {string} prop\n * @param {any} value\n * @param {Record<string, CustomElementPropDefinition>} props_definition\n * @param {'toAttribute' | 'toProp'} [transform]\n */\nfunction get_custom_element_value(prop, value, props_definition, transform) {\n\tconst type = props_definition[prop]?.type;\n\tvalue = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;\n\tif (!transform || !props_definition[prop]) {\n\t\treturn value;\n\t} else if (transform === 'toAttribute') {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value == null ? null : JSON.stringify(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value ? '' : null;\n\t\t\tcase 'Number':\n\t\t\t\treturn value == null ? null : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t} else {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value && JSON.parse(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value; // conversion already handled above\n\t\t\tcase 'Number':\n\t\t\t\treturn value != null ? +value : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t}\n}\n\n/**\n * @internal\n *\n * Turn a Svelte component into a custom element.\n * @param {import('./public.js').ComponentType} Component  A Svelte component constructor\n * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe\n * @param {string[]} slots  The slots to create\n * @param {string[]} accessors  Other accessors besides the ones for props the component has\n * @param {boolean} use_shadow_dom  Whether to use shadow DOM\n * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend]\n */\nexport function create_custom_element(\n\tComponent,\n\tprops_definition,\n\tslots,\n\taccessors,\n\tuse_shadow_dom,\n\textend\n) {\n\tlet Class = class extends SvelteElement {\n\t\tconstructor() {\n\t\t\tsuper(Component, slots, use_shadow_dom);\n\t\t\tthis.$$p_d = props_definition;\n\t\t}\n\t\tstatic get observedAttributes() {\n\t\t\treturn Object.keys(props_definition).map((key) =>\n\t\t\t\t(props_definition[key].attribute || key).toLowerCase()\n\t\t\t);\n\t\t}\n\t};\n\tObject.keys(props_definition).forEach((prop) => {\n\t\tObject.defineProperty(Class.prototype, prop, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];\n\t\t\t},\n\t\t\tset(value) {\n\t\t\t\tvalue = get_custom_element_value(prop, value, props_definition);\n\t\t\t\tthis.$$d[prop] = value;\n\t\t\t\tthis.$$c?.$set({ [prop]: value });\n\t\t\t}\n\t\t});\n\t});\n\taccessors.forEach((accessor) => {\n\t\tObject.defineProperty(Class.prototype, accessor, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c?.[accessor];\n\t\t\t}\n\t\t});\n\t});\n\tif (extend) {\n\t\t// @ts-expect-error - assigning here is fine\n\t\tClass = extend(Class);\n\t}\n\tComponent.element = /** @type {any} */ (Class);\n\treturn Class;\n}\n\n/**\n * Base class for Svelte components. Used when dev=false.\n *\n * @template {Record<string, any>} [Props=any]\n * @template {Record<string, any>} [Events=any]\n */\nexport class SvelteComponent {\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$ = undefined;\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$set = undefined;\n\n\t/** @returns {void} */\n\t$destroy() {\n\t\tdestroy_component(this, 1);\n\t\tthis.$destroy = noop;\n\t}\n\n\t/**\n\t * @template {Extract<keyof Events, string>} K\n\t * @param {K} type\n\t * @param {((e: Events[K]) => void) | null | undefined} callback\n\t * @returns {() => void}\n\t */\n\t$on(type, callback) {\n\t\tif (!is_function(callback)) {\n\t\t\treturn noop;\n\t\t}\n\t\tconst callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n\t\tcallbacks.push(callback);\n\t\treturn () => {\n\t\t\tconst index = callbacks.indexOf(callback);\n\t\t\tif (index !== -1) callbacks.splice(index, 1);\n\t\t};\n\t}\n\n\t/**\n\t * @param {Partial<Props>} props\n\t * @returns {void}\n\t */\n\t$set(props) {\n\t\tif (this.$$set && !is_empty(props)) {\n\t\t\tthis.$$.skip_bound = true;\n\t\t\tthis.$$set(props);\n\t\t\tthis.$$.skip_bound = false;\n\t\t}\n\t}\n}\n\n/**\n * @typedef {Object} CustomElementPropDefinition\n * @property {string} [attribute]\n * @property {boolean} [reflect]\n * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]\n */\n","// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n *\n * https://svelte.dev/docs/svelte-compiler#svelte-version\n * @type {string}\n */\nexport const VERSION = '4.2.19';\nexport const PUBLIC_VERSION = '4';\n","import { PUBLIC_VERSION } from '../../../shared/version.js';\n\nif (typeof window !== 'undefined')\n\t// @ts-ignore\n\t(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);\n"],"names":["is_client","now","raf","cb","noop","tasks","run_tasks","task","loop","callback","fulfill","is_hydrating","start_hydrating","end_hydrating","upper_bound","low","high","key","value","mid","init_hydrate","target","children","my_children","i","node","m","p","longest","current","seq_len","idx","new_len","lis","to_move","last","cur","b","j","anchor","append","get_root_for_style","root","append_empty_stylesheet","style_element","element","append_stylesheet","style","append_hydration","insert","insert_hydration","detach","destroy_each","iterations","detaching","name","svg_element","text","data","space","empty","listen","event","handler","options","attr","attribute","get_svelte_dataset","init_claim_info","nodes","claim_node","predicate","process_node","create_node","dont_update_last_index","result_node","replacement","claim_element_base","attributes","create_element","remove","v","claim_element","claim_text","data_str","claim_space","get_comment_idx","start","claim_html_tag","is_svg","start_index","end_index","HtmlTagHydration","html_tag_nodes","claimed_nodes","n","set_data","set_input_value","input","set_style","important","select_option","select","mounting","option","select_value","selected_option","toggle_class","toggle","custom_event","type","detail","bubbles","cancelable","HtmlTag","__publicField","html","construct_svelte_component","component","props","managed_styles","active","hash","str","create_style_information","doc","info","create_rule","a","duration","delay","ease","fn","uid","step","keyframes","t","rule","stylesheet","rules","animation","delete_rule","previous","next","anim","deleted","clear_rules","ownerNode","promise","wait","dispatch","direction","kind","outroing","outros","group_outros","check_outros","run_all","transition_in","block","local","transition_out","null_transition","create_in_transition","params","config","running","animation_name","cleanup","go","easing","linear","tick","css","start_time","end_time","add_render_callback","started","is_function","create_bidirectional_transition","intro","running_program","pending_program","original_inert_value","clear_animation","init","program","d","create_component","claim_component","parent_nodes","mount_component","fragment","after_update","new_on_destroy","run","destroy_component","$$","flush_render_callbacks","make_dirty","dirty_components","schedule_update","instance","create_fragment","not_equal","append_styles","dirty","parent_component","current_component","set_current_component","blank_object","ready","ret","rest","flush","SvelteComponent","callbacks","index","is_empty","PUBLIC_VERSION"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}